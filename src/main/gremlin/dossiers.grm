import net.wagstrom.research.github.IndexNames
import net.wagstrom.research.github.IdCols
import net.wagstrom.research.github.EdgeType
import net.wagstrom.research.github.VertexType
import net.wagstrom.research.github.PropertyName

// util
def merge(Map a, Map b) {
    //return (a + b).groupBy { it.id }.collect { it.value.collectEntries { it } }
    // ghetto merge!
    c = [:]
    c.putAll(a)
    c.putAll(b)
    return c
}

// this was yanked from roles, need to figure out how to import or promote to helpers
def getAllGitAccounts(IndexableGraph g, Vertex user) {
    // getting all of a users git accounts is tricky because they don't make all of their email addresses
    // public. Luckily, using these two methods we do a pretty good job of getting all of a users git_user
    // accounts
    gitAccounts = user.out(EdgeType.EMAIL). \
                       in(EdgeType.EMAIL). \
                       has("type", VertexType.GIT_USER). \
                       dedup().toSet()

    // this code has been superseded as it isn't always that accurate and can
    // grab accounts that don't belong to this user
    // gitAccounts = (gitAccounts as Set) + user.out(EdgeType.ISSUEEVENTACTOR). \
    //                  in(EdgeType.ISSUEEVENT).in(EdgeType.ISSUE). \
    //                  filter{it == repo}.back(3).out(EdgeType.EVENTCOMMIT). \
    //                  out(EdgeType.COMMITTER).dedup().toList()
    
    // here we need to be a little careful with finding additional accounts
    // this pipe takes all of the commits this person has tied to an issue,
    // and filters for those email addresses which are not associated with
    // a user yet. It assumes, and this is a big assumption, that if one of
    // these unparented links shows up in both COMMITTERS and PARENTS then
    // the user probably owns that account
    // traceAccountsCommitter = user.out(EdgeType.ISSUEEVENTACTOR).out(EdgeType.EVENTCOMMIT).out(EdgeType.COMMITTER). \
    //                          filter{it.type=="GIT_USER"}.out("EMAIL").dedup().filter{it.in("EMAIL").filter{it.type == "USER"}.count() == 0}.back(4).toList()
    // traceAccountsAuthor = user.out(EdgeType.ISSUEEVENTACTOR).out(EdgeType.EVENTCOMMIT).out(EdgeType.COMMITAUTHOR). \
    //                          filter{it.type=="GIT_USER"}.out("EMAIL").dedup().filter{it.in("EMAIL").filter{it.type == "USER"}.count() == 0}.back(4).toList()
    // traceAccounts = (traceAccountsCommitter as Set) + traceAccountsAuthor
    // a slightly more complicated but more accurate version of the above commands
    // this version requires that the supposedly unattached commit have the same author
    // and committer.                            
    traceAccounts = user.out(EdgeType.ISSUEEVENTACTOR).out(EdgeType.EVENTCOMMIT). \
         filter{it.out(EdgeType.COMMITTER).filter{it.type==VertexType.GIT_USER}.out(EdgeType.EMAIL).next() == \
                it.out(EdgeType.COMMITAUTHOR).filter{it.type==VertexType.GIT_USER}.out(EdgeType.EMAIL).next()}. \
         out(EdgeType.COMMITTER). \
         filter{it.type==VertexType.GIT_USER}.out(EdgeType.EMAIL).dedup().filter{it.in(EdgeType.EMAIL).filter{it.type == VertexType.USER}.count() == 0}. \
         back(4).dedup().toSet()
    
    gravatars = user.out(EdgeType.GRAVATAR). \
                     in(EdgeType.GRAVATARHASH). \
                     has(PropertyName.TYPE, VertexType.EMAIL). \
                     in(VertexType.EMAIL). \
                     has(PropertyName.TYPE, VertexType.GIT_USER).toSet()
            
    gitAccounts = gitAccounts + traceAccounts + gravatars
     
    allGitAccounts = [] as Set
    for (email in gitAccounts._().out(EdgeType.EMAIL).email.dedup().toSet()) {
        allGitAccounts += g.idx(IndexNames.EMAIL).get(IdCols.EMAIL, email)._().in(EdgeType.EMAIL).has("type", VertexType.GIT_USER).toSet()
    }

    return allGitAccounts
}

def belongsToRepo(Vertex repo, Vertex v) {
    def result
    switch (v.type) {
        // discussion_user
        case VertexType.COMMENT:
            // comment -> issue -> repository
            result = v.in(EdgeType.ISSUECOMMENT).in(EdgeType.ISSUE).next() == repo
            break
        case VertexType.COMMIT:
            // commit -> repository
            result = v.out(EdgeType.REPOSITORY).next() == repo
            break
        case VertexType.PULLREQUESTREVIEWCOMMENT:
            // pull request, not handling
            result = false
            break
        // issue_comment_owner
        // - comment
        // issue_event_actor
        case VertexType.ISSUE_EVENT:
            // issue event -> issue -> repository
            result = v.in("ISSUE_EVENT").in("ISSUE").next() == repo
            break
        // issue_event
        // - issue_event
        // git_user
        // - commit
    }
    return result
}
def getDossier(IndexableGraph g, Vertex repo, Vertex user) {
    // need to find a groovy equivalent of apply to clean this up
    gh_dossier = user.both(EdgeType.DISCUSSIONUSER, \
                           EdgeType.ISSUECOMMENTOWNER, \
                           EdgeType.ISSUEEVENTACTOR, \
                           EdgeType.ISSUEEVENT). \
                      filter{ belongsToRepo(repo, it) }. \
                      groupCount{it.type}.cap.next()
    g_dossier = getAllGitAccounts(g, user). \
                    //_().in(EdgeType.COMMITAUTHOR, \
                           //EdgeType.COMMITTER). \
                    _().in(EdgeType.COMMITTER). \
                    groupCount{it.type}.cap.next()
    return merge(gh_dossier, g_dossier)
}

def getDossierAsCSV(Vertex repo, Vertex user, Map dossier) {
    return [repo.name, \
            user.login, \
            dossier[VertexType.COMMENT], \
            dossier[VertexType.COMMIT], \
            dossier[VertexType.ISSUE_EVENT], \
            dossier[VertexType.ISSUE_EVENT] ].join(",")
}

g = new Neo4jGraph(Defaults.DBPATH)

//projects = Defaults.PROJECTS
projects = ["rails/rails", "rack/rack", "sinatra/sinatra"]
//user = repo.in("REPO_OWNER").next()

for (project in projects) {
    repo = g.idx(IndexNames.REPOSITORY).get(IdCols.REPOSITORY, project).next()
    users = Helpers.getAllRepositoryUsers(repo)
    for (user in users) {
        if (user instanceof Vertex) {
            println getDossierAsCSV(repo, user, getDossier(g, repo, user))
        } else {
            println "------invalid"
            println user.class
        }
    }
}

g.shutdown()

