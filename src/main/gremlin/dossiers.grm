import net.wagstrom.research.github.IndexNames
import net.wagstrom.research.github.IdCols
import net.wagstrom.research.github.EdgeType
import net.wagstrom.research.github.VertexType
import net.wagstrom.research.github.PropertyName

// util
def merge(Map a, Map b) {
    //return (a + b).groupBy { it.id }.collect { it.value.collectEntries { it } }
    // ghetto merge!
    c = [:]
    c.putAll(a)
    c.putAll(b)
    return c
}

def belongsToRepo(Vertex repo, Element e) {
    switch (e.label) {
        case null:
            // kill null first as this is likely a vertex
            break
        case EdgeType.DISCUSSIONUSER:
            return belongsToRepo(repo, e.inV.next())
        case EdgeType.ISSUEASSIGNEE:
            return belongsToRepo(repo, e.inV.next())
        case EdgeType.ISSUECOMMENTOWNER:
            return belongsToRepo(repo, e.inV.next())
        case EdgeType.ISSUEEVENTACTOR:
            return belongsToRepo(repo, e.inV.next())
        case EdgeType.ISSUEOWNER:
            return belongsToRepo(repo, e.inV.next())
        case EdgeType.PULLREQUESTCOMMENTOWNER:
            return belongsToRepo(repo, e.inV.next())
        case EdgeType.PULLREQUESTISSUEUSER:
            return belongsToRepo(repo, e.inV.next())
        case EdgeType.PULLREQUESTOWNER:
            return belongsToRepo(repo, e.inV.next())
        case EdgeType.PULLREQUESTREVIEWCOMMENTOWNER:
            return belongsToRepo(repo, e.inV.next())
        case EdgeType.COMMITAUTHOR:
            return belongsToRepo(repo, e.outV.next())
        case EdgeType.COMMITTER:
            return belongsToRepo(repo, e.outV.next())
    }
    switch (e.type) {
        case null:
            // kill null first as this is likely an edge
            break
        // discussion_user
        case VertexType.COMMENT:
            // comment -> issue -> repository
            return e.in(EdgeType.ISSUECOMMENT).in(EdgeType.ISSUE).next() == repo
        case VertexType.COMMIT:
            // commit -> repository
            return e.out(EdgeType.REPOSITORY).next() == repo
        case VertexType.PULLREQUESTREVIEWCOMMENT:
            // really not sure how to handle this...
            return false
        // issue_comment_owner
        // - comment
        // issue_event_actor
        case VertexType.ISSUE_EVENT:
            // issue event -> issue -> repository
            return e.in("ISSUE_EVENT").in("ISSUE").next() == repo
        case VertexType.ISSUE:
            // issue -> repository
            return e.in("ISSUE").next() == repo
        case VertexType.PULLREQUEST:
            // pullrequest -> repository
            return e.in("PULLREQUEST").next() == repo
        // issue_event
        // - issue_event
        // git_user
        // - commit
    }
}
def getDossier(IndexableGraph g, Vertex repo, Vertex user) {
    // need to find a groovy equivalent of apply to clean this up
    gh_dossier = user.bothE(EdgeType.DISCUSSIONUSER, \
                            EdgeType.ISSUEASSIGNEE, \
                            EdgeType.ISSUECOMMENTOWNER, \
                            EdgeType.ISSUEEVENTACTOR, \
                            EdgeType.ISSUEOWNER, \
                            EdgeType.PULLREQUESTCOMMENTOWNER, \
                            EdgeType.PULLREQUESTISSUEUSER, \
                            EdgeType.PULLREQUESTOWNER, \
                            EdgeType.PULLREQUESTREVIEWCOMMENTOWNER). \
                      filter{ belongsToRepo(repo, it) }. \
                      groupCount{it.label}.cap.next()
    g_dossier = Helpers.getAllGitAccounts(g, user). \
                    //_().in(EdgeType.COMMITAUTHOR, \
                           //EdgeType.COMMITTER). \
                    _().inE(EdgeType.COMMITTER). \
                    filter{ belongsToRepo(repo, it) }. \
                    groupCount{it.label}.cap.next()
    return merge(gh_dossier, g_dossier)
}

def getDossierAsCSV(Vertex repo, Vertex user, Map dossier) {
    return [repo.name, \
            user.login, \
            dossier[EdgeType.DISCUSSIONUSER] ?: 0, \
            dossier[EdgeType.ISSUEASSIGNEE] ?: 0, \
            dossier[EdgeType.ISSUECOMMENTOWNER] ?: 0, \
            dossier[EdgeType.ISSUEEVENTACTOR] ?: 0, \
            dossier[EdgeType.ISSUEOWNER] ?: 0, \
            dossier[EdgeType.PULLREQUESTCOMMENTOWNER] ?: 0, \
            dossier[EdgeType.PULLREQUESTISSUEUSER] ?: 0, \
            dossier[EdgeType.PULLREQUESTOWNER] ?: 0, \
            dossier[EdgeType.PULLREQUESTREVIEWCOMMENTOWNER] ?: 0, \
            dossier[EdgeType.COMMITTER] ?: 0 ].join(",")
}

// g = new Neo4jGraph(Defaults.DBPATH)

//projects = Defaults.PROJECTS
projects = ["rails/rails"]
//user = repo.in("REPO_OWNER").next()

for (project in projects) {
    repo = g.idx(IndexNames.REPOSITORY).get(IdCols.REPOSITORY, project).next()
    users = [g.idx(IndexNames.USER).get(IdCols.USER, "dhh").next()]
    // users = Helpers.getAllRepositoryUsers(repo)
    for (user in users) {
        if (user instanceof Vertex) {
            println getDossierAsCSV(repo, user, getDossier(g, repo, user))
        } else {
            println "------invalid"
            println user.class
        }
    }
}

// g.shutdown()

