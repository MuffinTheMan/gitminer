/**
 * produce information about roles in the community by mining the graph
 * database
 */
import net.wagstrom.research.github.IndexNames
import net.wagstrom.research.github.IdCols
import net.wagstrom.research.github.EdgeType
import net.wagstrom.research.github.VertexType

ROCKSTAR_THRESHOLD=0.20; // should be in the top 20% of followed links by people in the community
PRODDER_TIME_THRESHOLD=14*86400*1000; // number of ms that an issue should be idle before a prodder picks it up


def getAllGitAccounts(IndexableGraph g, Vertex user) {
    // getting all of a users git accounts is tricky because they don't make all of their email addresses
    // public. Luckily, using these two methods we do a pretty good job of getting all of a users git_user
    // accounts
    gitAccounts = user.out(EdgeType.EMAIL).in(EdgeType.EMAIL).filter{it.type==VertexType.GIT_USER}.dedup().toList()


    // this code has been superseded as it isn't always that accurate and can
    // grab accounts that don't belong to this user
    // gitAccounts = (gitAccounts as Set) + user.out(EdgeType.ISSUEEVENTACTOR). \
    //                  in(EdgeType.ISSUEEVENT).in(EdgeType.ISSUE). \
    //                  filter{it == repo}.back(3).out(EdgeType.EVENTCOMMIT). \
    //                  out(EdgeType.COMMITTER).dedup().toList()
    
    // here we need to be a little careful with finding additional accounts
    // this pipe takes all of the commits this person has tied to an issue,
    // and filters for those email addresses which are not associated with
    // a user yet. It assumes, and this is a big assumption, that if one of
    // these unparented links shows up in both COMMITTERS and PARENTS then
    // the user probably owns that account
    // traceAccountsCommitter = user.out(EdgeType.ISSUEEVENTACTOR).out(EdgeType.EVENTCOMMIT).out(EdgeType.COMMITTER). \
    //                          filter{it.type=="GIT_USER"}.out("EMAIL").dedup().filter{it.in("EMAIL").filter{it.type == "USER"}.count() == 0}.back(4).toList()
    // traceAccountsAuthor = user.out(EdgeType.ISSUEEVENTACTOR).out(EdgeType.EVENTCOMMIT).out(EdgeType.COMMITAUTHOR). \
    //                          filter{it.type=="GIT_USER"}.out("EMAIL").dedup().filter{it.in("EMAIL").filter{it.type == "USER"}.count() == 0}.back(4).toList()
    // traceAccounts = (traceAccountsCommitter as Set) + traceAccountsAuthor
    // a slightly more complicated but more accurate version of the above commands
    // this version requires that the supposedly unattached commit have the same author
    // and committer.                            
    traceAccounts = user.out(EdgeType.ISSUEEVENTACTOR).out(EdgeType.EVENTCOMMIT). \
         filter{it.out(EdgeType.COMMITTER).filter{it.type==VertexType.GIT_USER}.out(EdgeType.EMAIL).next() == \
                it.out(EdgeType.COMMITAUTHOR).filter{it.type==VertexType.GIT_USER}.out(EdgeType.EMAIL).next()}. \
         out(EdgeType.COMMITTER). \
         filter{it.type==VertexType.GIT_USER}.out(EdgeType.EMAIL).dedup().filter{it.in(EdgeType.EMAIL).filter{it.type == VertexType.USER}.count() == 0}. \
         back(4).dedup().toList()
            
    gitAccounts = (gitAccounts as Set) + traceAccounts
     
    allGitAccounts = [] as Set
    for (email in gitAccounts._().out("EMAIL").email.dedup().toList()) {
        allGitAccounts += g.idx(IndexNames.EMAIL).get(IdCols.EMAIL, email)._().in("EMAIL").filter{it.type=="GIT_USER"}.toList()
    }

    return allGitAccounts
}

def getIssueInfo(IndexableGraph g, Vertex issue) {
    // timeline is tuple of (eventDate, event)
    // where event can actually be any of the actual issue, issue comment, or issue event
    timeline = [Helpers.parseDate(issue.createdAt), issue]
    
    // first sort all of the issue comments
    issue.out(EdgeType.ISSUECOMMENT).sideEffect{timeline.add([Helpers.parseDate(it.createdAt), it])}.iterate()
    
    // next add all the issue events
    issue.out(EdgeType.ISSUEEVENT).sideEffect{timeline.add([Helpers.parseDate(it.createdAt), it])}.iterate()
    
    timeline.sort{a,b -> a[0] <=> b[0]}
    
    lastTime = null
    // fixme: need an index here
    for (element in timeline) {
    }
}

/**
 * Provides information about secondary attributes
 * 
 * Prodders
 * Stewards 
 * Code Warrior
 * Super Star
 * Community Rock Stars - individuals in the top 20% of contributors and also the top 20% of followers
 */
def devInfo(IndexableGraph g, Vertex user, Vertex repo, Map userSet) {
    gitAccounts = getAllGitAccounts(g, user)
                          
    // project rock star: following
    communityFollowing = user.out(EdgeType.FOLLOWING).filter{userSet["allUsers"].contains(it)}.count()
    // project rock star: coding conrtributions
    codingContributions = gitAccounts._().in(EdgeType.COMMITAUTHOR).out(EdgeType.REPOSITORY).filter{it == repo}.count()
    
    // community rock star: coding contributions
    // NOTE: this ONLY covers contributions to the projects we've pulled
    allCodingContributions = gitAccounts._().in(EdgeType.COMMITAUTHOR).count()
    allCodingProjects = gitAccounts._().in(EdgeType.COMMITAUTHOR).out(EdgeType.REPOSITORY).dedup().count()
    
    // project merged pull requests
    projectMergedPullRequests = user.in("PULLREQUEST_MERGED_BY").in("PULLREQUEST").filter{it==repo}.count()
    
    printf("User: %s\n", user.login)
    printf("  Community Following: %d\n", communityFollowing)
    printf("    Community Commits: %d\n", codingContributions)
    printf("          All Commits: %d\n", allCodingContributions)
    printf("         All Projects: %d\n", allCodingProjects)
    printf(" Pull Requests Merged: %d\n", projectMergedPullRequests)
}

g = new Neo4jGraph(Defaults.DBPATH)
projects = ["tinkerpop/gremlin"]

for (project in projects) {
    repo = g.idx(IndexNames.REPOSITORY).get(IdCols.REPOSITORY, project).next()
    println "\n\n******************************************"
    println repo.name

    watchers = repo.in(EdgeType.REPOWATCHED).toList()
    // collaborators: have admin rights on projects
    collaborators = repo.out(EdgeType.REPOCOLLABORATOR).toList()
    // contributors: have committed code to project
    contributors = repo.out(EdgeType.REPOCONTRIBUTOR).toList() + \
                   repo.in(EdgeType.REPOOWNER).dedup().toList()
    issueOwners = repo.out(EdgeType.ISSUE). \
                       in(EdgeType.ISSUEOWNER). \
                       dedup().toList()
    issueCommenters = repo.out(EdgeType.ISSUE). \
                           out(EdgeType.ISSUECOMMENT). \
                           in(EdgeType.ISSUECOMMENTOWNER).dedup().toList()
    pullRequestOwners = repo.out(EdgeType.PULLREQUEST). \
                             in(EdgeType.PULLREQUESTOWNER).dedup().toList()
    openPullRequestOwners = repo.out(EdgeType.PULLREQUEST). \
                                 filter{it.closedAt==null}.in(EdgeType.PULLREQUESTOWNER).dedup().toList()
    closedPullRequestOwners = repo.out(EdgeType.PULLREQUEST). \
                                   filter{it.closedAt!=null}.in(EdgeType.PULLREQUESTOWNER).dedup().toList()
    mergedPullRequestOwners = repo.out(EdgeType.PULLREQUEST). \
                                   filter{it.merged_at != null}.in(EdgeType.PULLREQUESTOWNER).dedup().toList()
    pullRequestCommenters = repo.out(EdgeType.PULLREQUEST). \
                                 out(EdgeType.PULLREQUESTDISCUSSION). \
                                 filter{it.type==VertexType.USER.toString()}.dedup().toList()
    mergers = repo.out(EdgeType.ISSUE). \
                   out(EdgeType.ISSUEEVENT). \
                   filter{it.event=="merged"}.in(EdgeType.ISSUEEVENTACTOR).dedup()
    forkOwners = repo.out(EdgeType.REPOFORK). \
                      in(EdgeType.REPOOWNER).dedup().toList()

    // FIXME: this should be converted to constants
    committers = repo.in("REPOSITORY").out("AUTHOR").filter{it.type=="GIT_USER"}.out("EMAIL").dedup().in("EMAIL").filter{it.type=="USER"}
     
    allActive = (collaborators + contributors + issueOwners + \
                issueCommenters + pullRequestOwners + \
                openPullRequestOwners + closedPullRequestOwners + \
                pullRequestCommenters + mergedPullRequestOwners + \
                mergers + forkOwners).unique()
    allUsers = (allActive as Set) + watchers
    allCollaborators = (collaborators as Set) + contributors

    /*
     * Lurkers - only watching the repo, no forks, issues, etc
     */
    println "Lurkers"
    println Helpers.setDifferenceLeft(watchers, allActive).login.sort{a,b -> a <=> b}
    
    /*
     * Issues - people active only on issues. This clearly needs a better name.
     */
    println "Issues"
    println Helpers.setDifferenceLeft((issueOwners + issueCommenters).unique(),
                                      (collaborators + contributors +
                                       pullRequestOwners +
                                       openPullRequestOwners + closedPullRequestOwners +
                                       pullRequestCommenters + mergedPullRequestOwners +
                                       mergers + forkOwners).unique()).login.sort{a,b -> a <=> b}
    /*
     * Independent - forked the repo, but no pull requests
     */
    println "Independent"
    println Helpers.setDifferenceLeft(forkOwners, \
                                      (pullRequestOwners + allCollaborators).unique()).login.sort{a,b -> a <=> b}
    /*
     * Wannabes - created a pull request, but never accepted
     */
    println "Wannabes"
    println Helpers.setDifferenceLeft(closedPullRequestOwners, mergedPullRequestOwners).login.sort{a,b -> a <=> b}
    
    /*
     * External Contributors - created a pull request, pull request
     * has been merged. No direct access.
     */
    println "External Contributors"
    println Helpers.setDifferenceLeft(mergedPullRequestOwners, collaborators).login.sort{a,b -> a <=> b}

    /*
     * Collaborators - have direct access to push to the main repo
     */
    println "Collaborators"
    println allCollaborators.login.sort{a,b -> a <=> b}

    userSet = ["allUsers": allUsers]
    for (collab in allCollaborators) {
        devInfo(g, collab, repo, userSet)
    }
}

g.shutdown()
