/**
 * produce information about roles in the community by mining the graph
 * database
 */
import net.wagstrom.research.github.IndexNames
import net.wagstrom.research.github.IdCols
import net.wagstrom.research.github.EdgeType
import net.wagstrom.research.github.VertexType
import net.wagstrom.research.github.PropertyName

ROCKSTAR_THRESHOLD=0.20; // should be in the top 20% of followed links by people in the community
PRODDER_TIME_THRESHOLD=14*86400 // number of seconds that an issue should be idle before a prodder picks it up
                                // we need to validate this by each project 

def getAllGitAccounts(IndexableGraph g, Vertex user) {
    // getting all of a users git accounts is tricky because they don't make all of their email addresses
    // public. Luckily, using these two methods we do a pretty good job of getting all of a users git_user
    // accounts
    gitAccounts = user.out(EdgeType.EMAIL).in(EdgeType.EMAIL).filter{it.type==VertexType.GIT_USER}.dedup().toList()


    // this code has been superseded as it isn't always that accurate and can
    // grab accounts that don't belong to this user
    // gitAccounts = (gitAccounts as Set) + user.out(EdgeType.ISSUEEVENTACTOR). \
    //                  in(EdgeType.ISSUEEVENT).in(EdgeType.ISSUE). \
    //                  filter{it == repo}.back(3).out(EdgeType.EVENTCOMMIT). \
    //                  out(EdgeType.COMMITTER).dedup().toList()
    
    // here we need to be a little careful with finding additional accounts
    // this pipe takes all of the commits this person has tied to an issue,
    // and filters for those email addresses which are not associated with
    // a user yet. It assumes, and this is a big assumption, that if one of
    // these unparented links shows up in both COMMITTERS and PARENTS then
    // the user probably owns that account
    // traceAccountsCommitter = user.out(EdgeType.ISSUEEVENTACTOR).out(EdgeType.EVENTCOMMIT).out(EdgeType.COMMITTER). \
    //                          filter{it.type=="GIT_USER"}.out("EMAIL").dedup().filter{it.in("EMAIL").filter{it.type == "USER"}.count() == 0}.back(4).toList()
    // traceAccountsAuthor = user.out(EdgeType.ISSUEEVENTACTOR).out(EdgeType.EVENTCOMMIT).out(EdgeType.COMMITAUTHOR). \
    //                          filter{it.type=="GIT_USER"}.out("EMAIL").dedup().filter{it.in("EMAIL").filter{it.type == "USER"}.count() == 0}.back(4).toList()
    // traceAccounts = (traceAccountsCommitter as Set) + traceAccountsAuthor
    // a slightly more complicated but more accurate version of the above commands
    // this version requires that the supposedly unattached commit have the same author
    // and committer.                            
    traceAccounts = user.out(EdgeType.ISSUEEVENTACTOR).out(EdgeType.EVENTCOMMIT). \
         filter{it.out(EdgeType.COMMITTER).filter{it.type==VertexType.GIT_USER}.out(EdgeType.EMAIL).next() == \
                it.out(EdgeType.COMMITAUTHOR).filter{it.type==VertexType.GIT_USER}.out(EdgeType.EMAIL).next()}. \
         out(EdgeType.COMMITTER). \
         filter{it.type==VertexType.GIT_USER}.out(EdgeType.EMAIL).dedup().filter{it.in(EdgeType.EMAIL).filter{it.type == VertexType.USER}.count() == 0}. \
         back(4).dedup().toList()
            
    gitAccounts = (gitAccounts as Set) + traceAccounts
     
    allGitAccounts = [] as Set
    for (email in gitAccounts._().out(EdgeType.EMAIL).email.dedup().toList()) {
        allGitAccounts += g.idx(IndexNames.EMAIL).get(IdCols.EMAIL, email)._().in(EdgeType.EMAIL).filter{it.type==VertexType.GIT_USER}.toList()
    }

    return allGitAccounts
}

def getUserFromVertex(Vertex v) {
    switch (v.type) {
        case VertexType.ISSUE:
            return v.in(EdgeType.ISSUEOWNER).next()
            break
        
        case VertexType.COMMENT:
            return v.in(EdgeType.ISSUECOMMENTOWNER).next()
            break
        
        case VertexType.ISSUE_EVENT:
            return v.in(EdgeType.ISSUEEVENTACTOR).next()
            break
        
        default:
            println "Unable to get User for vertex id=" + v.id + " type: " + v.type
            return null;
            break
    }
}

/**
 * calculate the users who are prodders
 * 
 * question: can users be prodders if they follow their own activities?
 * answer: yes
 * question: can user be prodders on issues they own
 * answer: yes
 */
def getIssueInfo(IndexableGraph g, Vertex issue) {
    prodders = []
    
    // timeline is tuple of (eventDate, event)
    // where event can actually be any of the actual issue, issue comment, or issue event
    timeline = [[Helpers.timestampToDate(issue.createdAt), issue]]
    
    // first sort all of the issue comments
    issue.out(EdgeType.ISSUECOMMENT). \
          sideEffect{timeline.add([Helpers.timestampToDate(it.createdAt), it])}. \
          iterate()
    
    // next add all the issue events
    issue.out(EdgeType.ISSUEEVENT). \
          hasNot("event", "subscribed"). \
          hasNot("event", "unsubscribed"). \
          hasNot("event", "mentioned"). \
          sideEffect{timeline.add([Helpers.timestampToDate(it.createdAt), it])}. \
          iterate()
    
    // next, if this is actually a pull request, we need to add the
    // actions associated with the pull request
    try { 
        pullRequest = g.idx(IndexNames.PULLREQUEST).get(IdCols.PULLREQUEST, issue.issue_id).next() 
        // fixme: add in pullrequest actions
    } catch (java.util.NoSuchElementException e) { }
    
    lastTime = null
    lastAction = null
    for (element in timeline.sort{a,b -> a[0] <=> b[0]}) {
        when = element[0]
        action = element[1]
    
        if (lastTime != null && Helpers.dateDifferenceAbs(when, lastTime) > PRODDER_TIME_THRESHOLD) {
            if (getUserFromVertex(action).login == "name") {
                println "action: " +  action  + " issue: " + issue.issue_id
            }
            prodders.add(getUserFromVertex(action))
        }
        lastTime = when
        lastAction = action
    }
    return prodders as Set
}

/**
 * Provides information about secondary attributes that can be used to calculate
 * other roles
 * 
 * Stewards - top 20% of pull requests merged and top 20% of issues closed
 * Code Warrior -
 * Project Rock Stars - individuals in the top 20% of contributors and also the top 20% of followers
 */
def devInfo(IndexableGraph g, Vertex user, Vertex repo, Map userSet) {
    gitAccounts = getAllGitAccounts(g, user)
                          
    // project rock star: following
    communityFollowing = user.out(EdgeType.FOLLOWING).filter{userSet["allUsers"].contains(it)}.count()
    // project rock star: coding conrtributions
    codingContributions = gitAccounts._().in(EdgeType.COMMITAUTHOR).out(EdgeType.REPOSITORY).filter{it == repo}.count()
    
    // community rock star: coding contributions
    // NOTE: this ONLY covers contributions to the projects we've pulled
    allCodingContributions = gitAccounts._().in(EdgeType.COMMITAUTHOR).count()
    allCodingProjects = gitAccounts._().in(EdgeType.COMMITAUTHOR).out(EdgeType.REPOSITORY).dedup().count()
    // look at people following...
    
    // project merged pull requests
    projectMergedPullRequests = user.in(EdgeType.PULLREQUESTMERGEDBY).in(EdgeType.PULLREQUEST).filter{it==repo}.count()

    // issues closed
    projectIssuesClosed = user.out(EdgeType.ISSUEEVENTACTOR). \
                               has(PropertyName.EVENT,"closed"). \
                               in(EdgeType.ISSUEEVENT). \
                               dedup(). \
                               in(EdgeType.ISSUE). \
                               filter{it == repo}.count()

//    println "User: " + user.login
//    println "  Community Following: " + communityFollowing
//    println "    Community Commits: " + codingContributions
//    println "          All Commits: " + allCodingContributions
//    println "         All Projects: " + allCodingProjects
//    println " Pull Requests Merged: " + projectMergedPullRequests

    return ["communityFollowing": communityFollowing,
            "codingContributions": codingContributions,
            "allCodingContributions": allCodingContributions,
            "allCodingProjects": allCodingProjects,
            "projectPullRequestsMerged": projectMergedPullRequests,
            "projectIssuesClosed": projectIssuesClosed]
}

def devInfoThreshold(Map devInfo, String key, float threshold) {
    int numEntries = devInfo.size() * threshold
    return devInfo.sort{a,b -> a.value[key] <=> b.value[key]}.keySet().asList().reverse()[0..numEntries] as Set    
}

g = new Neo4jGraph(Defaults.DBPATH)
projects = ["rails/rails"]

for (project in projects) {
    repo = g.idx(IndexNames.REPOSITORY).get(IdCols.REPOSITORY, project).next()
    println "\n\n******************************************"
    println repo.name

    watchers = repo.in(EdgeType.REPOWATCHED).toList()
    // collaborators: have admin rights on projects
    collaborators = repo.out(EdgeType.REPOCOLLABORATOR).toList()
    
    // contributors: have committed code to project
    contributors = repo.out(EdgeType.REPOCONTRIBUTOR).toList() + \
                   repo.in(EdgeType.REPOOWNER).dedup().toList()
    issueOwners = repo.out(EdgeType.ISSUE). \
                       in(EdgeType.ISSUEOWNER). \
                       dedup().toList()
    issueCommenters = repo.out(EdgeType.ISSUE). \
                           out(EdgeType.ISSUECOMMENT). \
                           in(EdgeType.ISSUECOMMENTOWNER).dedup().toList()
    issueSubscribers = repo.out(EdgeType.ISSUE). \
                            out(EdgeType.ISSUEEVENT). \
                            has(PropertyName.EVENT, "subscribed"). \
                            in(EdgeType.ISSUEEVENTACTOR).dedup().toList()
    pullRequestOwners = repo.out(EdgeType.PULLREQUEST). \
                             in(EdgeType.PULLREQUESTOWNER).dedup().toList()
    openPullRequestOwners = repo.out(EdgeType.PULLREQUEST). \
                                 filter{it.closedAt==null}.in(EdgeType.PULLREQUESTOWNER).dedup().toList()
    closedPullRequestOwners = repo.out(EdgeType.PULLREQUEST). \
                                   filter{it.closedAt!=null}.in(EdgeType.PULLREQUESTOWNER).dedup().toList()
    mergedPullRequestOwners = repo.out(EdgeType.PULLREQUEST). \
                                   filter{it.merged_at != null}.in(EdgeType.PULLREQUESTOWNER).dedup().toList()
    pullRequestCommenters = repo.out(EdgeType.PULLREQUEST). \
                                 out(EdgeType.PULLREQUESTDISCUSSION). \
                                 filter{it.type==VertexType.USER.toString()}.dedup().toList()
    mergers = repo.out(EdgeType.ISSUE). \
                   out(EdgeType.ISSUEEVENT). \
                   filter{it.event=="merged"}.in(EdgeType.ISSUEEVENTACTOR).dedup()
    forkOwners = repo.out(EdgeType.REPOFORK). \
                      in(EdgeType.REPOOWNER).dedup().toList()

    committers = repo.in(EdgeType.REPOSITORY). \
                      out(EdgeType.COMMITAUTHOR). \
                      filter{it.type==VertexType.GIT_USER}. \
                      out(EdgeType.EMAIL).dedup(). \
                      in(EdgeType.EMAIL). \
                      filter{it.type==VertexType.USER}
     
    allActive = (collaborators + contributors + issueOwners + \
                issueCommenters + pullRequestOwners + \
                openPullRequestOwners + closedPullRequestOwners + \
                pullRequestCommenters + mergedPullRequestOwners + \
                mergers + forkOwners).unique()
    allUsers = (allActive as Set) + watchers
    allCollaborators = (collaborators as Set) + contributors

    /*
     * Lurkers - only watching the repo or subscribed to an issue, no
     * forks, issues, etc
     */
    println "Lurkers"
    println Helpers.setDifferenceLeft((watchers + issueSubscribers), allActive).login.sort{a,b -> a <=> b}
    
    /*
     * Issues - people active only on issues. This clearly needs a better name.
     */
    println "Issues"
    println Helpers.setDifferenceLeft((issueOwners + issueCommenters + pullRequestCommenters).unique(),
                                      (collaborators + contributors +
                                       pullRequestOwners +
                                       openPullRequestOwners + closedPullRequestOwners +
                                       mergedPullRequestOwners +
                                       mergers + forkOwners).unique()).login.sort{a,b -> a <=> b}
    /*
     * Independent - forked the repo, but no pull requests
     */
    println "Independent"
    println Helpers.setDifferenceLeft(forkOwners, \
                                      (pullRequestOwners + allCollaborators).unique()).login.sort{a,b -> a <=> b}
    /*
     * Wannabes - created a pull request, but never accepted
     */
    println "Wannabes"
    println Helpers.setDifferenceLeft(closedPullRequestOwners, mergedPullRequestOwners).login.sort{a,b -> a <=> b}
    
    /*
     * External Contributors - created a pull request, pull request
     * has been merged. No direct access.
     */
    println "External Contributors"
    println Helpers.setDifferenceLeft(mergedPullRequestOwners, collaborators).login.sort{a,b -> a <=> b}

    /*
     * Collaborators - have direct access to push to the main repo
     */
    println "Collaborators"
    println allCollaborators.login.sort{a,b -> a <=> b}

    userSet = ["allUsers": allUsers]
    devStats = [:]
    for (collab in allCollaborators) {
        devStats[collab.login] = devInfo(g, collab, repo, userSet)
    }

    topFollowers = devInfoThreshold(devStats, "communityFollowing", ROCKSTAR_THRESHOLD)
    topCoders = devInfoThreshold(devStats, "codingContributions", ROCKSTAR_THRESHOLD)
    println "Project Rock Stars"
    println topFollowers.intersect(topCoders).sort()
    
    topIssueClosers = devInfoThreshold(devStats, "projectIssuesClosed", ROCKSTAR_THRESHOLD)
    topPullRequestClosers = devInfoThreshold(devStats, "projectPullRequestsMerged", ROCKSTAR_THRESHOLD)
    println "Project Stewards"
    println topIssueClosers.intersect(topPullRequestClosers).sort()
    
    allProdders = [:].withDefault{0}
    for (issue in repo.out(EdgeType.ISSUE)) {
        prodders = getIssueInfo(g, issue)        
        prodders.each{allProdders[it.login] += 1}
    }
    int numEntries = allProdders.size() * ROCKSTAR_THRESHOLD
    println "Prodders"
    println allProdders.sort{a,b -> a.value <=> b.value}.keySet().asList().reverse()[0..numEntries].sort()

}

g.shutdown()
